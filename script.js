// const number = prompt("Введите число:");

// if (number % 2 === 0) {
//   console.log("Число четное");
// } else {
//   console.log("Число нечетное");
// }

// Часто бывают ситуации когда нам необходимо выполнить одно и тоже действие много раз. 
// Пример из опыта,  часто выводим список товаров, создаем некоторое число элементов на html странице


// Пройдем все циклы и я расскажу в чем разница


// // while  ==== /* пока ~ в то время как */
   // - Используется, когда количество итераций заранее неизвестно и зависит от условия.
   // - Выполняет блок кода до тех пор, пока условие истинно.
   // - Условие проверяется перед каждой итерацией цикла.

/* Действия цикла называется итерация */

var i = 0
while(i <= 10) {
  console.log(i); /*  Без i++ ломается браузер*/
  i++             /* Потомучто значение переменной не изменеятся */
}




// do while 
// Проверку условия можно разместить под телом цикла, используя специальный синтаксис do..while:
  // - Работает подобно циклу while, но условие проверяется после каждой итерации.
  //  - Гарантирует, что блок кода будет выполнен хотя бы один раз, даже если условие изначально ложно.

var i = 0

do {
  console.log(i);
  ++i
} while (i < 5);


var i = 0

do { /* Сначала объяснить как работает цикл, затем добавить i++ и спросить почему выводит только четные числа */
  console.log(i);
  ++i 
  i++
} while (i < 5);



// for
/* Более сложный, но при этом самый распространённый цикл — цикл for. */
//   - Используется, когда заранее известно количество итераций. К тому же самый быстрый, хоть и не значительно

/* Пример из кода yearInP */
for (let index = 0; index < 10; index++) {
  console.log(index);
}
let answer = 1
for (let i = 1; i < 4; i++) {
  answer += i
// answer = answer + i 
  console.log(answer);
}
// закончим с циклами и расскажу про let, const, var

let answer = '1'
for (let i = 1; i < 4; i++) {
  answer += i
// answer = answer + i 
  console.log(answer);
}


///////////// ТЕРНАРНЫЙ ОПЕРАТОР

let a = +prompt('Введите число')

a = !isNaN(a) ? a : 10;

console.log(a);

for(let i = 0; i <= a; i++) {
    console.log(i); 
}

// ОБЛАСТЬ ВИДИМОСТИ - Зона в которой переменные доступны, иными словами мы можем к ним обратиться 
console.log(1);
// ГЛОБАЛЬНАЯ

function exampleFunc() {
  console.log(2);
  // ФУНКЦИОНАЛЬНАЯ
  if (condition) {
    // БЛОЧНАЯ
  console.log(3);
  console.log(4);
  }
}

for (let i = 0; i < 5; i++) {
  // БЛОЧНАЯ
  console.log(5);  
}
// МЫ МОЖЕМ ИСПОЛЬЗОВАТЬ ПЕРЕМЕННЫЕ ВНУТРИ ЭТОЙ САМОЙ ОБЛАСТИ ВИДИМОСТИ И ТАКЖЕ С РОДИТЕЛЬСКОЙ. НО НАОБОРОТ ЭТО НЕ РАБОТАЕТ 

// ЕСЛИ МЫ СОЗДАЕМ ПЕРЕМЕННУЮ В ГЛОБАЛЬНОЙ ЗОНЕ ВИДИМОСТИ МЫ МОЖЕМ ИСПОЛЬЗОВАТЬ ЕЕ И В ФУНКЦИОНАЬНОЙ И БЛОЧНОЙ
// У РОДИТЕЛЬСКИХ ЭЛЕМЕНТОВ НЕТ ДОСТУПА К ДОЧЕРНИМ ОБЛАСТЯМ т.е если мы создадим переменную внутри 

// недостатки var 
// 1) не ограничивается блоком кода (ее ограничивает только функция, остальные нет)
// 2) такую переменную можно переобъявлять 
//  var x = 1 
//  var x = 2 (ошибки не будет)

var i = 19

function forExample() {}

for (var i = 0; i < 5; i++) {
  forExample()
}

console.log(i); /* Получим 5 потомучто мы ее переобъявили */

// 3) Мы можем использовать ее до объявления

console.log(s);/*  Просто получим undefined */
var s = 0 


// let и const имеют блочную область видимости. И ограничиваются любыми блоками и функциями
if(true){
  var   a = 1 
  let   b = 2
  const c = 3 
}
console.log(a);/* Игнорирует область видимости */
console.log(b); /* ошитбка переменная вне области видимости */
console.log(c); /* Код ломается */

// С циклом будет тоже самое. Потому что цикл также имеет блочную облшасть видимости
// в функции ошибки будут у всех переменных

function x(){
  var   a = 1 
  let   b = 2
  const c = 3
}
console.log(a);
console.log(b);
console.log(c);

// 2) НЕЛЬЗЯ ИСПОЛЬЗОВАТЬ ДЛЯ ПОВТОРНОГО ОБЪЯВЛЕНИЯ ПЕРЕМЕНННОЙ 

var x = 1 
var x = 2
console.log(x); /* Окей */ 

let x = 1 
let x = 2
console.log(x); /* Ошибка */ 
// с const тоже самое происходит

// 3) let и const видны только после объявления 
let x = 1
console.log(x + y); /* Ошибка, использование до объявленния */
let y = 2

// РАЗНИЦА МЕЖДУ LET и CONST 
// let позволяет себя переобъявлять
// const нет 

let color = "green"
    color = "red"
console.log(color); 
  
const color = "green"
      color = "red"
console.log(color); /* Ошибка */

// ПОЧЕМУ ПРЕДПОЧТИТЕЛЬНО ИСПОЛЬЗОВАТЬ CONST
// ЕСЛИ ВЫ ЗНАЕТЕ ЧТО ПЕРЕМЕННАЯ НЕ БУДЕТ МЕНЯТЬСЯ ТО ЛУЧШЕ ИСПОЛЬЗОВАТЬ CONST
// 1) БЕЗОПАСНОСТЬ, мы могли забыть, что создавали переменную и объявляем ее заново, это могло бы привесити к ошибкам. Но const предостерегает нас от подобных ошибок
// 2) ЧИТАЕМОСТЬ. ДРУГОЙ РАЗРАБОТЧИК МОЖЕТ ПОНЯТЬ ЧТО ПЕРЕМЕННАЯ НЕ ДОЛЖНА ИЗМЕНЯТЬСЯ 


// ЗАДАНИЕ НА УРОКЕ ДЛЯ СТУДЕНТОВ

/* 

Факториал числа - это умножение от 1 до самого числа например (1 * 2 * 3 * 4 * 5) = 120
При помощи цикла вывести Факториал числа от 1 до 5 и вывести только конечный результат работы цикла. Цикл for

10 - 15 минут

*/

let answer = 1;
for(let i = 1; i < 6; i++) {
    answer = answer * i;
}
console.log(answer);



